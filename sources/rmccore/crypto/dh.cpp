//
//  dh.cpp
//  rmccore
//
//  Created by Gavin Ye on 10/19/17.
//  Copyright ï¿½ 2017 NextLabs, Inc. All rights reserved.
//

#include "stdafx.h"

#include "rmccore/rmccore.h"
#include "rmccore/crypto/crypto.h"
#include "rmccore/crypto/dh.h"

#include "openssl/dh.h"
#include "openssl/bio.h"
#include "openssl/x509.h"
#include "openssl/pem.h"
#include "openssl/err.h"

namespace RMCCORE {
namespace CRYPT {


std::vector<uint8_t> loadDhPublicKeyFromCert(const std::string& der)
{
    BIO *bio = nullptr;
    X509 *cert = nullptr;
    EVP_PKEY * pubkey = nullptr;
    std::vector<uint8_t> key;

    do {

        bio = BIO_new(BIO_s_mem());
        if(nullptr == bio)
            break;
        cert = d2i_X509_bio(bio, NULL);
        if(nullptr == cert)
            break;
        pubkey = X509_get_pubkey(cert);
        if(nullptr == pubkey)
            break;
        DH* dh = EVP_PKEY_get1_DH(pubkey);
        if(nullptr == dh)
            break;

        // DH_set0_key()


    } while(false);
    if(nullptr != pubkey) {
        EVP_PKEY_free (pubkey);
        pubkey = nullptr;
    }
    if(nullptr != cert) {
        X509_free(cert);
        cert = nullptr;
    }
    if (nullptr != bio) {
        BIO_free(bio);
        bio = nullptr;
    }

    return key;
}

static const uint8_t DH_P_1024[128] = {
    0xE8, 0xEA, 0xFD, 0xE6, 0xF9, 0xE0, 0x15, 0x44, 0xA9, 0x7A, 0x8C, 0x41, 0x26, 0x2C, 0x64, 0xE6,
    0x87, 0x90, 0x8E, 0x78, 0xF7, 0xF5, 0xA5, 0x89, 0xDC, 0x95, 0xB5, 0x6A, 0x01, 0x5C, 0xC3, 0x42,
    0xFA, 0x86, 0x95, 0xF7, 0x5F, 0x00, 0x5D, 0x86, 0xE8, 0x6B, 0xB2, 0x5E, 0x82, 0x23, 0x81, 0xD1,
    0x1B, 0xE3, 0xFF, 0x43, 0xDD, 0xE0, 0x27, 0x47, 0x00, 0x23, 0x42, 0x32, 0x65, 0x8B, 0x5E, 0xD5,
    0xD5, 0xFF, 0xE1, 0xA6, 0xEB, 0xAE, 0xB5, 0x26, 0x7E, 0x04, 0xC3, 0x67, 0x09, 0x65, 0xDF, 0xD9,
    0xE1, 0x69, 0xCE, 0x18, 0xD9, 0xC2, 0xF5, 0xEE, 0x9C, 0x0F, 0x2B, 0xD6, 0xF4, 0xD3, 0x9D, 0xC6,
    0xFE, 0x86, 0x56, 0x09, 0x57, 0x68, 0xAC, 0xEB, 0x05, 0x23, 0x6D, 0x86, 0xC7, 0x7C, 0xD9, 0xC2,
    0x3D, 0x8B, 0x29, 0x1C, 0x38, 0xA7, 0x81, 0x6A, 0x9E, 0xD8, 0x19, 0x7A, 0x82, 0x57, 0xE4, 0x47
};

static const uint8_t DH_G_1024[128] = {
    0xC5, 0xBA, 0x27, 0xAA, 0x74, 0xCB, 0xD8, 0x89, 0xCB, 0x8D, 0xB1, 0x9D, 0x7D, 0xC5, 0x69, 0xC5,
    0xF1, 0x55, 0xEA, 0x66, 0x75, 0xE2, 0xF1, 0x2A, 0x15, 0x4B, 0xFF, 0xA8, 0x0E, 0x1F, 0xAA, 0xD8,
    0x42, 0x14, 0x76, 0x2A, 0xA2, 0x10, 0xFD, 0x2D, 0xE5, 0x9D, 0x4D, 0x89, 0x08, 0x9B, 0x2E, 0x57,
    0x29, 0xD3, 0x2C, 0xC2, 0x5A, 0x24, 0xE0, 0x7C, 0x4A, 0x9F, 0xA8, 0x76, 0x45, 0xAE, 0x87, 0x0D,
    0x92, 0xB1, 0x3E, 0x7F, 0x31, 0xE8, 0x26, 0x55, 0x75, 0xB9, 0x80, 0x7A, 0xC1, 0x9B, 0x6F, 0xCC,
    0x92, 0x17, 0x24, 0xAE, 0xC2, 0xFB, 0x8A, 0x87, 0x6E, 0x72, 0x83, 0x5B, 0x3B, 0x23, 0xB5, 0x62,
    0x4C, 0xE1, 0xCA, 0xE7, 0x39, 0x03, 0xCA, 0xCF, 0x95, 0x48, 0x62, 0x3E, 0x5F, 0x5F, 0xF2, 0x7A,
    0x2A, 0xF5, 0xB1, 0x5D, 0xCE, 0x56, 0xB3, 0x08, 0xD8, 0xE0, 0xDC, 0x3C, 0x19, 0xC2, 0x02, 0x07
};

static const uint8_t DH_P_2048[256] = {
    0xD3, 0x10, 0x12, 0x5B, 0x29, 0x4D, 0xBD, 0x85, 0x68, 0x14, 0xDF, 0xD4, 0xBA, 0xB4, 0xDC, 0x76,
    0x7D, 0xF6, 0xA9, 0x99, 0xC9, 0xED, 0xFA, 0x8F, 0x8D, 0x7B, 0x12, 0x55, 0x1F, 0x8D, 0x71, 0xEF,
    0x60, 0x32, 0x35, 0x74, 0x05, 0xC7, 0xF1, 0x1E, 0xE1, 0x47, 0xDB, 0x03, 0x32, 0x71, 0x6F, 0xC8,
    0xFD, 0x85, 0xED, 0x02, 0x75, 0x85, 0x26, 0x83, 0x60, 0xD1, 0x6B, 0xD7, 0x61, 0x56, 0x3D, 0x7D,
    0x16, 0x59, 0xD4, 0xD7, 0x3D, 0xAE, 0xD6, 0x17, 0xF3, 0xE4, 0x22, 0x3F, 0x48, 0xBC, 0xEF, 0xA4,
    0x21, 0x86, 0x0C, 0x3F, 0xC4, 0x39, 0x3D, 0x27, 0x54, 0x56, 0x77, 0xB2, 0x24, 0x59, 0xE8, 0x52,
    0xF5, 0x25, 0x4D, 0x3A, 0xC5, 0x8C, 0x0D, 0x63, 0xDD, 0x79, 0xDE, 0x2D, 0x8D, 0x86, 0x8C, 0xD9,
    0x40, 0xDE, 0xCF, 0x5A, 0x27, 0x46, 0x05, 0xDB, 0x0E, 0xEE, 0x76, 0x20, 0x20, 0xC3, 0x9D, 0x0F,
    0x64, 0x86, 0x60, 0x65, 0x80, 0xEA, 0xAC, 0xCE, 0x16, 0xFB, 0x70, 0xFB, 0x7C, 0x75, 0x9E, 0xA9,
    0xAA, 0xBA, 0xB4, 0xDC, 0xBF, 0x94, 0x18, 0x91, 0xB0, 0xCE, 0x94, 0xEC, 0x4D, 0x3D, 0x59, 0x54,
    0x21, 0x7C, 0x6E, 0x84, 0xA9, 0x27, 0x4F, 0x1A, 0xB8, 0x60, 0x73, 0xBD, 0xF9, 0xDC, 0x85, 0x1E,
    0x56, 0x3B, 0x90, 0x45, 0x5B, 0x83, 0x97, 0xDA, 0xE3, 0xA1, 0xB9, 0x98, 0x60, 0x7B, 0xB7, 0x69,
    0x9C, 0xEA, 0x08, 0x05, 0xA7, 0xFF, 0x01, 0x3E, 0xF4, 0x4F, 0xDE, 0x7A, 0xF8, 0x30, 0xF1, 0xFD,
    0x05, 0x1F, 0xFA, 0xEC, 0x53, 0x9C, 0xE4, 0x45, 0x2D, 0x82, 0x29, 0x09, 0x8A, 0xE3, 0xEE, 0x20,
    0x08, 0xAB, 0x9D, 0xB7, 0xB2, 0xC9, 0x48, 0x31, 0x2C, 0xBC, 0x01, 0x37, 0xC0, 0x82, 0xD6, 0x67,
    0x26, 0x18, 0xE1, 0xBF, 0xE5, 0xD5, 0x00, 0x6E, 0x81, 0x0D, 0xC7, 0xAA, 0x7F, 0x1E, 0x6E, 0xE3
};

static const uint8_t DH_G_2048[256] = {
    0x64, 0xAC, 0xEB, 0xA5, 0xF7, 0xBC, 0x80, 0x3E, 0xF2, 0x97, 0x31, 0xC9, 0xC6, 0xAE, 0x00, 0x9B,
    0x86, 0xFC, 0x52, 0x01, 0xF8, 0x1B, 0xC2, 0xB8, 0xF8, 0x48, 0x90, 0xFC, 0xF7, 0x1C, 0xAD, 0x51,
    0xC1, 0x42, 0x9F, 0xD2, 0x61, 0xA2, 0xA7, 0x15, 0xC8, 0x94, 0x61, 0x54, 0xE0, 0xE4, 0xE2, 0x8E,
    0xF6, 0xB2, 0xD4, 0x93, 0xCC, 0x17, 0x39, 0xF5, 0x65, 0x9E, 0x9F, 0x14, 0xDD, 0x14, 0x03, 0x7F,
    0x5F, 0xE7, 0x2B, 0x3B, 0xA4, 0xD9, 0xBC, 0xB3, 0xB9, 0x5B, 0x84, 0x17, 0xBD, 0xA4, 0x8F, 0x11,
    0x8E, 0x61, 0xC8, 0x21, 0x4C, 0xF8, 0xD5, 0x58, 0xDA, 0x67, 0x74, 0xF0, 0x8B, 0x58, 0xD9, 0x7B,
    0x2C, 0xCE, 0x20, 0xF5, 0xAA, 0x2F, 0x8E, 0x95, 0x39, 0xC0, 0x14, 0xE7, 0x76, 0x1E, 0x4E, 0x63,
    0x36, 0xCF, 0xFC, 0x35, 0x12, 0x7D, 0xDD, 0x52, 0x72, 0x06, 0x76, 0x6A, 0xE7, 0x20, 0x45, 0xC1,
    0x1B, 0x0F, 0xF4, 0xDA, 0x76, 0x17, 0x25, 0x23, 0x71, 0x3B, 0x31, 0xC9, 0xF1, 0x8A, 0xBA, 0xBA,
    0x92, 0x61, 0x2B, 0xDE, 0x10, 0x51, 0x41, 0xF0, 0x4D, 0xB5, 0xDA, 0x3C, 0x39, 0xCD, 0xE5, 0xC6,
    0x87, 0x7B, 0x7F, 0x8C, 0xD9, 0x69, 0x49, 0xFC, 0xC8, 0x76, 0xE2, 0xC1, 0x22, 0x4F, 0xB9, 0x18,
    0x8D, 0x71, 0x4F, 0xDD, 0x6C, 0xB8, 0x06, 0x82, 0xF8, 0x96, 0x78, 0x33, 0xAD, 0x4B, 0x51, 0x35,
    0x4A, 0x8D, 0x58, 0x59, 0x8E, 0x6B, 0x2D, 0xEF, 0x45, 0x71, 0xA5, 0x97, 0xAD, 0x39, 0xBD, 0x31,
    0x77, 0xD5, 0x4B, 0x24, 0xCA, 0x51, 0x8E, 0xDA, 0x99, 0x6E, 0xED, 0xBA, 0x8A, 0x31, 0xD5, 0x87,
    0x6E, 0xFE, 0xD8, 0xAA, 0x44, 0x02, 0x3C, 0xC9, 0xF1, 0x3D, 0x86, 0xDC, 0xB4, 0xDD, 0xFC, 0xF3,
    0x89, 0xC7, 0xA1, 0x43, 0x50, 0x82, 0xEF, 0x69, 0x70, 0x36, 0x03, 0x63, 0x83, 0x25, 0x95, 0x4E
};

DhKey::DhKey(const uint8_t* vp, const uint8_t* vg, uint32_t vsize)
    : p(vp, vp + vsize/8)
    , g(vg, vg + vsize/8)
{
    init();
}

DhKey::DhKey(const uint8_t* vp, const uint8_t* vg, const uint8_t vx, const uint8_t vy, uint32_t vsize)
    : p(vp, vp + vsize/8)
    , g(vg, vg + vsize/8)
    , x(vx ? std::vector<uint8_t>(vx, vx + vsize/8) : std::vector<uint8_t>())
    , y(vy ? std::vector<uint8_t>(vy, vy + vsize/8) : std::vector<uint8_t>())
{
}

DhKey::DhKey(const DhKey& rhs)
    : p(rhs.p)
    , g(rhs.g)
    , x(rhs.x)
    , y(rhs.y)
{
}

DhKey::~DhKey()
{
}

DhKey& DhKey::operator = (const DhKey& rhs)
{
    if (this != &rhs) {
        p = rhs.p;
        g = rhs.g;
        x = rhs.x;
        y = rhs.y;
    }
    return *this;
}

#ifndef USE_OPENSSL_110_OR_ABOVE
static void DH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
{
    if (p != NULL)
        *p = dh->p;
    if (q != NULL)
        *q = dh->q;
    if (g != NULL)
        *g = dh->g;
}

int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
{
    /* If the fields p and g in d are NULL, the corresponding input
    * parameters MUST be non-NULL.  q may remain NULL.
    */
    if ((dh->p == NULL && p == NULL)
        || (dh->g == NULL && g == NULL))
        return 0;

    if (p != NULL) {
        BN_free(dh->p);
        dh->p = p;
    }
    if (q != NULL) {
        BN_free(dh->q);
        dh->q = q;
    }
    if (g != NULL) {
        BN_free(dh->g);
        dh->g = g;
    }

    if (q != NULL) {
        dh->length = BN_num_bits(q);
    }

    return 1;
}

static void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key)
{
    if (pub_key != NULL)
        *pub_key = dh->pub_key;
    if (priv_key != NULL)
        *priv_key = dh->priv_key;
}

int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
{
    if (pub_key != NULL) {
        BN_free(dh->pub_key);
        dh->pub_key = pub_key;
    }
    if (priv_key != NULL) {
        BN_free(dh->priv_key);
        dh->priv_key = priv_key;
    }

    return 1;
}
#endif

DhKey DhKey::loadFromPem(const std::string& s)
{
    DhKey dhk;
    BIO *bio = nullptr;
    X509 *cert = nullptr;
    EVP_PKEY *pubkey = nullptr;
    std::vector<uint8_t> key;

    do {

        bio = BIO_new(BIO_s_mem());
        if(nullptr == bio)
            break;
        BIO_write(bio, s.c_str(), (int)s.length());
        cert = PEM_read_bio_X509(bio, NULL, 0, NULL); 
        if(nullptr == cert)
            break;
        pubkey = X509_get_pubkey(cert);
        if(nullptr == pubkey)
            break;
        DH* dh = EVP_PKEY_get1_DH(pubkey);
        if(nullptr == dh)
            break;
        const uint32_t len = (uint32_t)EVP_PKEY_bits(pubkey);

        const BIGNUM* vp = nullptr;
        const BIGNUM* vq = nullptr;
        const BIGNUM* vg = nullptr;
        const BIGNUM* vx = nullptr;
        const BIGNUM* vy = nullptr;

        DH_get0_pqg(dh, &vp, &vq, &vg);
        DH_get0_key(dh, &vy, &vx);

        if(vp == nullptr || vg == nullptr || vy == nullptr)
            break;

        dhk.getP().resize(len/8, 0);
        BN_bn2bin(vp, dhk.getP().data());
        dhk.getG().resize(len/8, 0);
        BN_bn2bin(vg, dhk.getG().data());
        dhk.getY().resize(len/8, 0);
        BN_bn2bin(vy, dhk.getY().data());

        if (vx) {
            dhk.getX().resize(len/8, 0);
            BN_bn2bin(vx, dhk.getX().data());
        }

    } while(false);
    if(nullptr != pubkey) {
        EVP_PKEY_free(pubkey);
        pubkey = nullptr;
    }
    if(nullptr != cert) {
        X509_free(cert);
        cert = nullptr;
    }
    if (nullptr != bio) {
        BIO_free(bio);
        bio = nullptr;
    }

    return dhk;
}

static std::string removeLineBreak(const std::string& s)
{
    std::string result;
    for (auto c : s) {
        if(c != '\r' && c != '\n')
            result.append(&c, 1);
    }
    return result;
}

std::string DhKey::getPubkeyPem(bool withHeader) const
{
    std::string result;
    BIO *bio = nullptr;
    DH* dh = nullptr;
    EVP_PKEY *pubkey = nullptr;
	unsigned long err = 0;
	char buf[1024];

    if(p.empty() || g.empty())
        return result;

    do {

        dh = DH_new();
		if (nullptr == dh)
		{
			err = ERR_get_error();
			ERR_error_string(err, buf);
			break;
		}
        if(0 == DH_set0_pqg(dh, BN_bin2bn(p.data(), (int)p.size(), nullptr), nullptr, BN_bin2bn(g.data(), (int)g.size(), nullptr)))
            break;
        if(0 == DH_set0_key(dh, BN_bin2bn(y.data(), (int)y.size(), nullptr), nullptr))
            break;
        pubkey = EVP_PKEY_new();
        if(pubkey == nullptr)
            break;
        if(!EVP_PKEY_set1_DH(pubkey, dh))
            break;

        bio = BIO_new(BIO_s_mem());
        if(bio == nullptr)
            break;

        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
        PEM_write_bio_PUBKEY(bio, pubkey);

        BUF_MEM *biomptr;
        BIO_get_mem_ptr(bio, &biomptr);
        std::vector<char> buf(biomptr->length + 1, 0);
        BIO_read(bio, buf.data(), (int)biomptr->length);
        result = buf.data();

        if (!withHeader) {
            static const std::string header("-----BEGIN PUBLIC KEY-----");
            static const std::string footer("-----END PUBLIC KEY-----");
            result = removeLineBreak(result);
            result = result.substr(header.length(), result.length() - header.length() - footer.length());
        }

    } while(false);
    if(nullptr != bio) {
        BIO_free(bio);
        bio = nullptr;
    }
    if(nullptr != pubkey) {
        EVP_PKEY_free(pubkey);
        pubkey = nullptr;
    }
    if (dh != nullptr) {
        DH_free(dh);
        dh = nullptr;
    }

    return result;
}

bool DhKey::reset()
{
    if(p.empty() || g.empty())
        return false;
    x.clear();
    y.clear();
    init();
    return true;
}

void DhKey::init()
{
    DH* dh = nullptr;

    if(p.empty() || g.empty())
        return;

    do {

        const BIGNUM* bnx = nullptr;
        const BIGNUM* bny = nullptr;
		unsigned long err = 0;
		char buf[1024];

        dh = DH_new();
        if(nullptr == dh)
		{
			err = ERR_get_error();
			ERR_error_string(err, buf);
			break;
		}    
        if(0 == DH_set0_pqg(dh, BN_bin2bn(p.data(), (int)p.size(), nullptr), nullptr, BN_bin2bn(g.data(), (int)g.size(), nullptr)))
            break;
        if(0 == DH_generate_key(dh))
            break;
        DH_get0_key(dh, &bny, &bnx);
        if (nullptr != bny) {
            y.resize(p.size(), 0);
            BN_bn2bin(bny, y.data());
        }
        if (nullptr != bnx) {
            x.resize(p.size(), 0);
            BN_bn2bin(bny, x.data());
        }

    } while(false);
    if (dh != nullptr) {
        DH_free(dh);
        dh = nullptr;
    }
}

DhKey1024::DhKey1024()
    : DhKey(DH_P_1024, DH_G_1024, 1024)
{
}

DhKey1024::DhKey1024(const uint8_t* vp, const uint8_t* vg)
    : DhKey(vp, vg, 1024)
{
}

DhKey1024::~DhKey1024()
{
}


DhKey2048::DhKey2048()
    : DhKey(DH_P_2048, DH_G_2048, 2048)
{
}

DhKey2048::DhKey2048(const uint8_t* vp, const uint8_t* vg)
    : DhKey(vp, vg, 2048)
{
}

DhKey2048::~DhKey2048()
{
}


}
}
